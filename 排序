  1.选择排序-简单选择排序
  2.选择排序-堆排序
  3.插入排序-直接插入排序@稳定
  4.插入排序-希尔排序
  5.交换排序-快速排序
  6.交换排序-冒泡排序@稳定
  7.归并排序@稳定
  8.桶排序/基数排序
    
    
    
# 1.简单选择排序
每一趟从待排序的数据元素中选出最小（最大）的元素，顺序放在待排序的数列最前，直到全部待排序的数据元素全部排完。
def j_sort(a):
  l = len(a)
  temp = 0

  for j in range(0,l-1):
        count = j  #记录最小元素下标
        #每次找出最小元素
        for i in range(j,l-1):
              if a[count] > a[i+1]:
                    count = i+1
        #交换最小元素和待排序元素中最前一个
        '''if count != j:
              temp = a[j]
              a[j] = a[count]
              a[count] = temp '''
        a[j], a[count] = a[count], a[j] #实现跟上述代码一样
  for i in range(0,l):
+        print(a[i])

if __name__ == "__main__":
      a = [10, 2, 5, 1, 3, 7, 3]
      j_sort(a)




# 2.堆排序

def d_sort(arr):
      l = len(arr)
      for i in range(int(l/2-1), -1, -1):
            adjustHead(arr,i,l)
      # 交换堆顶和最后一个元素，并调整堆结构
      for j in range(l-1, 0, -1):
            arr[0], arr[j] = arr[j], arr[0] #将堆顶元素和末尾元素进行交换
            adjustHead(arr, 0, j) #重新对对进行调整
      for k in range(0,l):
            print(arr[k])

#构造大顶堆            
def adjustHead(a, i, l):
      temp = a[i] #取出当前元素
      k = 2*i + 1 #从左子节点开始，即2*i+1
      while k < l:
            if k+1 < l & a[k] < a[k+1]: #若果左子节点小于右子节点，k指向右子节点
                  k=k+1
            if a[k] > temp: #如果子节点大于父节点，将子节点赋值给父节点，并将子节点下标记录下来，后面将父节点值赋值给该子节点
                  a[i] = a[k]
                  i = k
            else:
                  break
            k = 2*k + 1 #把该节点当作父节点，继续操作
      a[i] = temp #将父节点值赋值给该子节点
                  
if __name__ == "__main__":
      a = [10,2,4,5]
      d_sort(a)





插入排序思想：每一趟将一个待排序元素，按其排序码大小插入到前面已经排好序的一组元素的适当位置上，直到所有待排序元素元素全部插入为止
直接插入排序

直接插入排序是假定前i个构成的子序列是处于已排序的情况下进行排序的，然后将第i个元素与前i个构成的子序列逆序进行比较，如果是要升序排序，则比较第i个元素是否比j=i-1(i-1需要>=0)的元素大，如果是则第i个元素的位置（即j+1的位置上）保持不动，反之则将j=i-1的元素放置到i的位置，再进行第i个元素与j=i-2(i-2需要>=0)的,依次进行，如果第i个元素刚好比j=i-3大，则将第i个元素插入到j=i-2（即j+1的位置）上！

百度百科： 直接插入排序

算法实现
# 3.直接插入排序
def zc_sort(a):
      l = len(a)
      j=0
      for i in range(1,l):
            temp = a[i]
            for j in range(i-1, -1, -1):
                  if  temp < a[j]:  #如果第i个元素大于前i个元素中的第j个
                        a[j+1] = a[j] #则第j个元素先后移1位
                        a[j] = temp #将i个元素赋值给空着的位置
                  else:   #如果第i个元素小于等于前i个元素中的第j个则结束循环
                        break
      for i in range(0,l):
            print(a[i])

if __name__ == "__main__":
      a = [1,7,3,6,2,6]
      zc_sort(a)



4.希尔排序

转自：https://www.cnblogs.com/chengxiao/p/6104371.html

百度百科： 希尔排序

算法实现：

def shell_sort(a):
     l = int(len(a)/2)
     #生成增量列表
     gap_list = []
     while l > 0:
          gap_list.append(l)
          l = int(l/2)
     print(gap_list)
     for gap in gap_list:#增量gap，并逐步缩小增量 
          #print(gap)
          for i in range(gap, len(a)):#从第gap个元素，逐个对其所在组进行直接插入排序操作
               j = i
               while j -gap >= 0 and a[j-gap] > a[j]:
                    swap(a, j, j-gap)  #交换两个元素
                    j = j - gap
                              
     for i in range(0,len(a)):
          print(a[i])

def swap(arr, a, b):
     arr[a] = arr[a] + arr[b]
     arr[b] = arr[a] - arr[b]
     arr[a] = arr[a] - arr[b]


if __name__== "__main__":
      a = [1,0,4,-1,2,7,9,8,10, 3,6,5,18]
      shell_sort(a)













